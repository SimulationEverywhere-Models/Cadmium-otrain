/**
* Zachary Dunnigan
*
* StationArrivalGenerator:
* Cadmium implementation of CD++ StationArrivalGenerator.cpp atomic model
*/

#ifndef _STATIONARRIVALGENERATOR_HPP__
#define _STATIONARRIVALGENERATOR_HPP__

#include <cadmium/modeling/ports.hpp>
#include <cadmium/modeling/message_bag.hpp>

#include <limits>
#include <assert.h>
#include <string>
#include <random>

#include "../data_structures/stationnumber.hpp"

using namespace cadmium;
using namespace std;

//Port definition
struct StationArrivalGenerator_defs{
    struct StationNumber : public out_port<StationNumber_t> {};
};

template<typename TIME> 
class StationArrivalGenerator{
    public:
    // ports definition
    using output_ports=tuple<typename StationArrivalGenerator_defs::StationNumber>;
	using input_ports=tuple<>;	//unused, no input port for generator
	
    // state definition
    struct state_type{
        bool active;
		bool Bayview;
		bool CarlingS;
		bool CarlingN;
		bool CarletonS;
		bool CarletonN;
        bool ConfedS;
		bool ConfedN;
		bool Greenboro;
		bool initializing;
    }; 
    state_type state;
	
    // default constructor
    StationArrivalGenerator() {
        state.active = true;
        state.Bayview = true;		// Bayview is where the train is initially generated by default with an immediate "arrival" output
		state.CarlingS = false;
		state.CarlingN = false;
		state.CarletonS = false;
		state.CarletonN = false;
		state.ConfedS = false;
		state.ConfedN = false;
		state.Greenboro = false;
		state.initializing = true;	// In order to generate an arrival at Bayview immediately
    }
	
	// external transition
    void external_transition(TIME e, typename make_message_bags<input_ports>::type mbs) { 
                           
    }
    // confluence transition
    void confluence_transition(TIME e, typename make_message_bags<input_ports>::type mbs) {
		internal_transition();
        external_transition(TIME(), move(mbs));
    }
	
    // internal transition
    void internal_transition() {
		state.initializing = false;
        switch(state.active){
			case(true) :
				if(state.Bayview){
					state.Bayview = false;
					state.CarlingS = true;
				} else if(state.CarlingS) {
					state.CarlingS = false;
					state.CarletonS = true;
				} else if(state.CarletonS) {
					state.CarletonS = false;
					state.ConfedS = true;
				} else if(state.ConfedS) {
					state.ConfedS = false;
					state.Greenboro = true;
				} else if(state.Greenboro) {
					state.Greenboro = false;
					state.ConfedN = true;
				} else if(state.ConfedN) {
					state.ConfedN = false;
					state.CarletonN = true;
				} else if(state.CarletonN) {
					state.CarletonN = false;
					state.CarlingN = true;
				} else if(state.CarlingN) {
					state.CarlingN = false;
					state.Bayview = true;
				}
			case(false) :;	// Never happens, generator is always active while simulation running
		}
    }
	

    // output function
    typename make_message_bags<output_ports>::type output() const {
        typename make_message_bags<output_ports>::type bags;
        StationNumber_t out;
		if(state.Bayview){
			out.direction = 0;
			out.station = 1;
		} else if(state.CarlingS) {
			out.direction = 0;
			out.station = 2;
		} else if(state.CarletonS) {
			out.direction = 0;
			out.station = 3;
		} else if(state.ConfedS) {
			out.direction = 0;
			out.station = 4;
		} else if(state.Greenboro) {
			out.direction = 1;
			out.station = 5;
		} else if(state.ConfedN) {
			out.direction = 1;
			out.station = 4;
		} else if(state.CarletonN) {
			out.direction = 1;
			out.station = 3;
		} else if(state.CarlingN) {
			out.direction = 1;
			out.station = 2;
		}		
		get_messages<typename StationArrivalGenerator_defs::StationNumber>(bags).push_back(out);
        return bags;
    }
	
    // time_advance function
    TIME time_advance() const {
        TIME next_internal;
		if (state.initializing){
			next_internal = TIME("00:00:00:000");
		} else if (state.active) {            
			next_internal = TIME("00:03:45:000");
		} else {
			next_internal = numeric_limits<TIME>::infinity();
		}
    return next_internal;

    }

    friend ostringstream& operator<<(ostringstream& os, const typename StationArrivalGenerator<TIME>::state_type& i) {
		if (i.initializing){
			os << "OTrain is generated and initialized to immediately arrive at its default station (Bayview)";
		} else if(i.CarlingS){
			os << "Next stop south to Carling Station";
		} else if(i.CarletonS) {
			os << "Next stop south to Carleton Station";;
		} else if(i.ConfedS) {
			os << "Next stop south to Confed Station";;
		} else if(i.Greenboro) {
			os << "Next stop south to Greenboro Station";;
		} else if(i.ConfedN) {
			os << "Next stop north to Confed Station";;
		} else if(i.CarletonN) {
			os << "Next stop north to Carleton Station";;
		} else if(i.CarlingN) {
			os << "Next stop north to Carling Station";;
		} else if(i.Bayview) {
			os << "Next stop north to Bayview Station";;
		}
		return os;
    }
};    
#endif // _STATIONARRIVALGENERATOR_HPP_